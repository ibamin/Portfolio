변수
-전역 변수
{ } 밖이나 함수 외부에서 선언한 변수
프로그램 어디에서나 접근이 가능한 변수
프로그램이 종료될 때 까지 메모리에 존재
여러프로그램에 적용할 수 있으나 각 함수에대한 지배력은 약해 함수에 같은 이름이 존재하면 주도권이 넘어간다.
최기화 필수 아님 컴파일러가 초기화가 안되어 있으면 0으로 초기화 해주기 때문
-지역 변수
{ }나 함수 안에서 선언한 변수
선언도니 { }안에서만 작동
초기화 필수

예제 코드
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>

int A;
int B;
int add() {
	return A + B;
}

int main() {
	int answer;
	A = 5;
	B = 7;
	answer = add();
	printf("%d + %d = %d\n", A, B, answer);
}


생존 기간
정적 할당 static allocation
자동 할당 automatic allocation

저장 유형 지정자
auto : 쓰지않아도 자동 지정 지역변수를 지정할 때 들어감 묵시적 적용
static : 한번만 초기화 됨 (현 파일의 함수들간에 사용되는 global변수) 함수의 반환형으로 
사용되면 함수가 존재하는 파일에서만 사용가능
예제 코드
int save() {
	static int balance = 0;
	int money;
	printf("입출금(0 입력시 종료) : ");
	scanf("%d", &money);
	if (money == 0) return 0;
	if (money > 0) printf("%d\t\t", money);
	else printf("\t%d\t", money);

	balance += money;
	printf("%d\n", balance);
	return 1;
}

void play() {
	printf("==================================\n");
	printf("입금\t출금\t총합\n");
	printf("==================================\n");
	while (save());
	printf("==================================\n");
}

int main() {
	play();
}
register : cpu에 변수를 저장 //그리 좋은 방법이 아니라 사용 권장 x
exstern : 다른 파일에 속하는 변수들을 서로 연결하는 함수 (외부 파일과 연결) 초기화는 원본 파일에서 사용가능 전역변수에서만 사용가능
예시 코드(main.c)
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>


extern void f2();
extern void f1();
int main() {
	f1();
}
(sub.c)
#include <stdio.h>

static void f1() {
	printf("f1()이 호출되었습니다.\n");
}

void f2() {
	f1();
	printf("f2()가 호출되었습니다,\n");
}

가변 매개 변수
매개변수를 가변적으로 사용가능하도록 함
#include <stdarg.h>에 선언되어있음
사용예시 int sum(int,...); int answer=sum(4(변수갯수 지정),4,3,2,1); 매리트가 그리 크지 않다 알아만 두자!


배열
배열 : 동일한 타입의 데이터가 여러개 저장되어 있는 데이터 저장 장소
[자료형] [배열이름] [배열의 크기]
Index를 통해 접근이 가능 ( index는 0~정의된 배열의 크기-1만큼 존재)
배열은 메모리에 연속적으로 배당된다. 
배열이름 : 배열의 첫번째 index의 주소값을 저장하고 있음
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>
#define sdt 3

void print(int arr[]) {
	printf("---------------------------------------\n");
	for (int i = 0; i < 10; i++) printf("%d ", i + 1);
	printf("\n");
	printf("---------------------------------------\n");
	for (int i = 0; i < 10; i++) printf("%d ", arr[i]);
}

int select(int set[]) {
	int n;
	print(set);
	printf("\n다음중 선택해 주세요 :");
	scanf("%d", &n);
	if (n <= 0 || n > 10) {
		printf("잘못된 좌석입니다 처음으로 돌아갑니다\n");
		return 0;
	}
	if (set[n - 1] == 1) {
		printf("이미 예약된 좌석입니다. 다시 선택해 주십시오.\n");
		return select(set);
	}
	else {
		set[n - 1] = 1;
		printf("정상적으로 예약되었습니다\n");
	}
	return 1;
}

int main() {
	int set[10] = { 0, };
	char c,v;
	
	while (1) {
		printf("예약하시겠습니까?(y/n)");
		scanf(" %c", &c);
		if (c == 'n') {
			printf("다음에 다시 찾아주십시오.\n");
		}
		if(c!='y' && c!='n')
		{
			printf("잘못된 입력으로 종료합니다.");
			break;
		}

		printf("한분 이십니까?(y/n)");
		scanf(" %c", &v);
		if (c == 'y' && v=='y') {
			if (!select(set)) continue;
		}
		else if (c == 'y' && v == 'n') {
			int cnt = 0;
			if (select(set)) cnt++;
			if (select(set)) cnt++;
			printf("%d분 예약성공하셨습니다\n", cnt);
		} 
	}
}

call by reference : 포인터나 배열과같은 형태의 주소값으로 연산을 이어나가는 방법으로 이와 같은 방법으로 전달되었을 경우
함수에서 값을 수정하여 반환한다
call by value : 데이터로 함수가 시작한 경우로서 함수내부에서의 연산이 매개변수로간 값에 적용되지 않는다

#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>
#define stdt 5

void square_array(int a[],int size) {
	for (int i = 0; i < size; i++) a[i] *= a[i];
}

void print_array(int a[],int size) {
	for (int i = 0; i < size; i++) printf("%d ", a[i]);
	printf("\n");
}

int main() {
	int a[7] = { 1,2,3,4,5,6,7 };

	print_array(a,7);
	square_array(a, 7);
	print_array(a, 7);
}


정렬
선택 정렬
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>
#define size 10

void swap(int* a, int* b) {
	int tmp=*a;
	*a = *b;
	*b = tmp;
}

int main() {
	int list[size] = { 3,2,9,7,1,4,8,0,6,5 };
	int tmp;
	for (int i = 0; i < size - 1; i++) {
		for (int j = i + 1; j < size; j++) {
			if (list[i] > list[j]) {
				swap(&list[i], &list[j]);
			}
		}
	}
	for (int i = 0; i < size; i++) printf("%d ", list[i]);
}
